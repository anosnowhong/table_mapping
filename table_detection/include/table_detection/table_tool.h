#ifndef TABLE_MAPPING_TABLE_TOOL_H
#define TABLE_MAPPING_TABLE_TOOL_H

#include <ros/ros.h>
#include <pcl_ros/point_cloud.h>
#include <mongodb_store/message_store.h>
#include <opencv2/core/core.hpp>
//PCL HEADERS
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/features/integral_image_normal.h>
#include <pcl/visualization/cloud_viewer.h>
#include <pcl/surface/convex_hull.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/project_inliers.h>
#include <pcl/filters/conditional_removal.h>
#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/features/normal_3d.h>
#include <pcl/features/normal_3d_omp.h>
#include <pcl/surface/concave_hull.h>
//ROS MESSAGES
#include <std_msgs/Int32.h>
#include <sensor_msgs/PointCloud2.h>
#include <table_detection/Table.h>
#include <table_detection/table_neighbour_arr.h>
#include <table_detection/table_merge_info.h>

using namespace std;
#define Debug true

/*
 * Table template class provides the ability to process various point cloud data, generate
 * and save table to database.
 * Provide ROS entrance for communicating with mongodb_store node.
 */
template <class Point>
class Table{

public:

    typedef Point point_type;
    typedef pcl::PointCloud<point_type> cloud_type;
    typedef typename cloud_type::Ptr cloud_ptr;
    typedef typename cloud_type::ConstPtr cloud_const_ptr;

    Table();
    //create instance for ROS
    Table(ros::NodeHandlePtr nh_in);
    //used for table plane extraction, init with parameters
    Table(ros::NodeHandlePtr nh_in, float pn_angle);

    /*
     * Project points to a 2D plane and then extract convex and concave hull
     */
    void plane_convex(Table::cloud_ptr cloud_in, Table::cloud_ptr cloud_out);

    void plane_concave(Table::cloud_ptr cloud_in, Table::cloud_ptr cloud_out);

    /*
     * recursively extract plane, and check their normal angle.
     * input: point cloud to extract
     */
    void tb_extract_it(Table::cloud_ptr cloud_in);
    /*
     * table plane extraction method
     * pure data process, no database operation, function as class method.
     * return remaining point cloud indices(may still contains plane, iteration is expected to extract all)
     * return false if no plane detected, otherwise true.
     */
    bool tb_extract(Table::cloud_ptr cloud_in);
    /*
     * extract possible plane and check normal direction, keep plane that suit the threshold.
     * Need communicate with mongodb_store
     * param:
     *  collection: mongodb collection to store planes.
     *  threshold: angle to filter out non-horizontal planes
     *  Note: a int value is stored in given collection to identify old and new data
     */
    void tb_detection(std::string collection, bool iteration=false);
    /*
     *
     */
    void table_normal();
    /*
     * Given index of table merge them using convex hull
     */
    void table_merge(std::vector<std::vector<int> > merge_index);
    /*
     * A point in polygen check
     * run after one round observation
     * return ture if merge able
     */
    void overlap_detect(std::string collection, std::vector<std::vector<int> > &overlap_index);
    /*
     * Given collection that contains table centre group(table centre generated by each round)
     * try to merge table centres that are close enough
     * */
    void merge_table_centre(std::string collection);

    /* construct a kdtree to store table centre(which is calculate during each scan), (load all table cloud from db)
     * Given db collection that contains sensor_msgs::PointCloud2
     * calculate all the centre in given collection, and put in a given pcl kdtree
     */
    void dbtable_kdtree(std::string collection, pcl::KdTreeFLANN<point_type> &kdtree);

    /*
     * Instead of table centre using all table clouds extracted
     */
    void dbtable_cloud_kdtree(std::string collection, pcl::KdTreeFLANN<point_type> &kdtree, int begin, int end);

    /*
     * calculate table centre for a single scan
     * store_point and collection is enabled by default,
     * return cv::Point3f, centre point.
     */
    point_type table_cloud_centre(sensor_msgs::PointCloud2 msg,
                                   bool store_point=true,
                                   std::string collection="table_centre");
    void dbtable_cloud_centre(std::string collection, std::vector<point_type>& table_centre_index);

private:
    //need init by ros node
    ros::NodeHandlePtr nh;
    //PARAMETERS
    //a threshold angle between two normal
    float normal_angle;
    const double PI = 3.1415926;
    //used to describe a plane points(table_inliers) and equation(table_coeffi)
    pcl::PointIndices::Ptr table_inliers;
    pcl::ModelCoefficients::Ptr table_coeffi;

};
#endif //TABLE_MAPPING_TABLE_TOOL_H


